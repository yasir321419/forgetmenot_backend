name: Node.js CI

on:
  push:
    branches: ["main"]
  workflow_dispatch:

defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: self-hosted
    timeout-minutes: 30

    env:
      DB_NAME:              ${{ secrets.DB_NAME }}
      DATABASE_URL:         ${{ secrets.DATABASE_URL }}       # URL-encode special chars in password!
      LIVE_DATABASE_URL:    ${{ secrets.LIVE_DATABASE_URL }}  # optional fallback
      PORT:                 ${{ secrets.PORT }}               # e.g. 4000
      HOST:                 ${{ secrets.HOST }}               # e.g. 127.0.0.1 or 0.0.0.0
      API_PRIFEX:           ${{ secrets.API_PRIFEX }}
      SECRET_KEY:           ${{ secrets.SECRET_KEY }}
      MAIL_SERVICE:         ${{ secrets.MAIL_SERVICE }}
      MAIL_HOST:            ${{ secrets.MAIL_HOST }}
      MAIL_USERNAME:        ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD:        ${{ secrets.MAIL_PASSWORD }}
      MAIL_ENCRYPTION:      ${{ secrets.MAIL_ENCRYPTION }}
      MAIL_PORT:            ${{ secrets.MAIL_PORT }}
      MAIL_FROM_NAME:       ${{ secrets.MAIL_FROM_NAME }}
      TWILIO_ACCOUNT_SID:   ${{ secrets.TWILIO_ACCOUNT_SID }}
      TWILIO_AUTH_TOKEN:    ${{ secrets.TWILIO_AUTH_TOKEN }}
      NUMBER:               ${{ secrets.NUMBER }}

    steps:
      # 0) Runner info (no secrets printed)
      - name: Kickoff
        run: |
          set -e
          echo "== CI kickoff at $(date -u) =="
          echo "Runner: $(uname -a)"
          whoami
          node -v || true
          npm -v || true

      # 1) Checkout
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Create .env from secrets
      - name: Create .env
        run: |
          set -euo pipefail
          DB_URL_VALUE="${DATABASE_URL:-${LIVE_DATABASE_URL:-}}"
          if [ -z "${DB_URL_VALUE}" ]; then
            echo "ERROR: DATABASE_URL resolved to empty"; exit 1
          fi

          rm -f .env
          {
            printf 'DATABASE_URL=%s\n' "${DB_URL_VALUE}"
            printf 'LIVE_DATABASE_URL=%s\n' "${DB_URL_VALUE}"
            printf 'NODE_ENV=production\n'
            printf 'HOST=%s\n' "${HOST:-127.0.0.1}"
            printf 'PORT=%s\n' "${PORT:-4000}"
            printf 'API_PRIFEX=%s\n' "${API_PRIFEX:-/api/v1}"
            printf 'SECRET_KEY=%s\n' "${SECRET_KEY}"
            printf 'MAIL_SERVICE=%s\n' "${MAIL_SERVICE}"
            printf 'MAIL_HOST=%s\n' "${MAIL_HOST}"
            printf 'MAIL_USERNAME=%s\n' "${MAIL_USERNAME}"
            printf 'MAIL_PASSWORD=%s\n' "${MAIL_PASSWORD}"
            printf 'MAIL_ENCRYPTION=%s\n' "${MAIL_ENCRYPTION}"
            printf 'MAIL_PORT=%s\n' "${MAIL_PORT}"
            printf 'MAIL_FROM_NAME=%s\n' "${MAIL_FROM_NAME}"
            printf 'TWILIO_ACCOUNT_SID=%s\n' "${TWILIO_ACCOUNT_SID}"
            printf 'TWILIO_AUTH_TOKEN=%s\n' "${TWILIO_AUTH_TOKEN}"
            printf 'NUMBER=%s\n' "${NUMBER}"
          } > .env

          echo "Wrote .env with $(wc -l < .env) lines."

          # Validate DATABASE_URL exists & non-empty
          if ! grep -q '^DATABASE_URL=' .env; then
            echo "ERROR: DATABASE_URL not written to .env"; exit 1
          fi
          LEN="$(awk -F= '/^DATABASE_URL=/{print length($2)}' .env)"
          if [ "${LEN}" -eq 0 ]; then
            echo "ERROR: DATABASE_URL in .env is empty"; exit 1
          fi

      # 3) Validate critical env presence (masked) + URL format
      - name: Validate env & URL format
        run: |
          set -euo pipefail
          for k in DATABASE_URL PORT HOST API_PRIFEX; do
            if [ -z "${!k:-}" ]; then echo "MISSING $k"; exit 1; fi
            echo "$k is set"
          done
          node -e "try{new URL(process.env.DATABASE_URL);console.log('DATABASE_URL looks valid')}catch(e){console.error('BAD DATABASE_URL:', e.message);process.exit(1)}"

      # 4) Sanity check PORT & loopback (prove we can bind)
      - name: Sanity check PORT & loopback
        run: |
          set -euo pipefail
          : "${PORT:=4000}"
          node -e "require('http').createServer((_,r)=>r.end('ok')).listen(process.env.PORT||4000,'127.0.0.1',()=>console.log('temp up'))" &
          sleep 1
          curl -fsS "http://127.0.0.1:${PORT}/" >/dev/null
          kill %1 || true
          echo "Temp server reachable on ${PORT}"

      # 5) Node.js with cache
      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: npm

      # 6) Install dependencies
      - name: Install dependencies
        run: npm ci --loglevel=verbose --foreground-scripts

      # 7) Build & Prisma (optional)
      - name: Build & Prisma
        run: |
          set -euxo pipefail
          npm run build --if-present
          unset DATABASE_URL || true
          npx prisma generate || true
          npx prisma migrate deploy || npx prisma db push

      # 8) Ensure PM2
      - name: Ensure PM2 installed
        run: |
          command -v pm2 >/dev/null 2>&1 || sudo npm i -g pm2
          pm2 -v

      # 9) Start/Reload with PM2 (env + entry detection + single process)
      - name: Start/Reload app with PM2
        run: |
          set -euo pipefail
          APP_NAME="forgetmenot-backend"
          APP_DIR="$GITHUB_WORKSPACE"
          cd "$APP_DIR"

          # Export .env for PM2
          set -a
          [ -f .env ] && . ./.env
          set +a

          : "${HOST:=127.0.0.1}"
          : "${PORT:=4000}"

          # Express entries preferred
          if [ -f index.js ]; then
            ENTRY="index.js"
          elif [ -f server.js ]; then
            ENTRY="server.js"
          elif [ -f dist/main.js ]; then
            ENTRY="dist/main.js"
          else
            echo "ERROR: No entry file found (index.js, server.js, or dist/main.js)."
            ls -la
            exit 1
          fi

          # Remove legacy processes so they can't resurrect
          pm2 delete ollie-backend || true
          pm2 delete index || true

          # Start or reload canonical app (use same node as shell)
          if pm2 describe "$APP_NAME" >/dev/null 2>&1; then
            pm2 reload "$APP_NAME" --update-env
          else
            pm2 start "$ENTRY" --name "$APP_NAME" --time --cwd "$APP_DIR" --interpreter "$(which node)"
          fi

          pm2 save
          echo "PM2 started $APP_NAME with ENTRY=$ENTRY PORT=$PORT HOST=$HOST"

          # Verify listener; show logs if not
          for i in 1 2 3 4 5; do
            sudo ss -ltnp | grep -qE ":${PORT}\b" && { echo "Listener on :${PORT}"; exit 0; }
            sleep 1
          done
          echo "No listener on :${PORT}. Showing PM2 logs:"
          pm2 logs "$APP_NAME" --lines 200 || true
          exit 1

      # 10) Show startup logs
      - name: Show startup logs
        run: |
          set -e
          pm2 status || true
          tail -n 120 ~/.pm2/logs/forgetmenot-backend-out.log   || true
          tail -n 120 ~/.pm2/logs/forgetmenot-backend-error.log || true

      # 11) Health check (tries /health then /; prints listeners and logs on fail)
      - name: Health check
        run: |
          set -euo pipefail
          : "${PORT:=4000}"
          URL1="http://127.0.0.1:${PORT}/health"
          URL2="http://127.0.0.1:${PORT}/"

          echo "Active listeners before check:"
          sudo ss -ltnp | grep -E ":${PORT}\b|:80\b" || echo "no listeners on ${PORT} (yet)"

          for i in {1..30}; do
            if curl -fsS "$URL1" >/dev/null || curl -fsS "$URL2" >/dev/null; then
              echo "Health check passed at $(date -u)"
              exit 0
            fi
            echo "Waiting for app on ${URL1} / ${URL2}... ($i/30)"
            sleep 2
          done

          echo "Health check FAILED"
          pm2 status || true
          pm2 logs forgetmenot-backend --lines 200 || true
          exit 1

      # 12) Final status
      - name: PM2 status & recent logs
        run: |
          pm2 status
          timeout 8s pm2 logs forgetmenot-backend --lines 80 --nostream || true
